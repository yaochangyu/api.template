---
name: api-template-bdd-guide
description: ASP.NET Core 8.0 Web API 開發指南，涵蓋分層架構（Controller-Handler-Repository）、BDD 測試流程（Reqnroll）、Result Pattern、Redis 快取策略、TraceContext 中介軟體設計。適用於建立企業級 API、程式碼審查、架構決策。
---

# API Template BDD Development Guide

基於 ASP.NET Core 8.0 的 Web API 開發範本，採用 BDD（行為驅動開發）、分層架構、Docker 測試環境的最佳實踐指南。

## 使用時機 (When to Use This Skill)

- 使用此 API Template 建立新的 .NET Web API 專案
- 實作基於 BDD 的整合測試（Reqnroll + Testcontainers）
- 設計分層架構（Controller → Handler → Repository）
- 實作 Result Pattern 錯誤處理模式
- 配置 Redis 多層快取策略
- 設計 TraceContext 追蹤與中介軟體
- 從 OpenAPI 規格產生 API 程式碼（API First）
- 使用 EF Core 反向工程或 Code First 開發
- 審查 .NET API 程式碼品質與架構

## 核心概念 (Core Concepts)

### 1. 專案架構（分層設計）

```
src/be/
├── {ProjectName}.WebAPI/          # Web API 主專案
│   ├── Contract/                  # 從 OpenAPI 自動產生的 Controller
│   │   └── AutoGenerated/         # ⚠️ 不可手動編輯
│   ├── {Feature}/                 # 功能模組（如 Member, Order）
│   │   ├── {Feature}Controller.cs       # HTTP 請求處理
│   │   ├── {Feature}Handler.cs          # 業務邏輯協調
│   │   └── {Feature}Repository.cs       # 資料存取
│   ├── TraceContext.cs            # 不可變追蹤上下文
│   ├── TraceContextMiddleware.cs  # 追蹤中介軟體
│   └── Program.cs
├── {ProjectName}.Infrastructure/  # 跨領域基礎設施
│   ├── Cache/                     # 快取服務（Redis + Memory）
│   ├── Middleware/                # 共用中介軟體
│   └── Extensions/                # DI 擴充方法
├── {ProjectName}.DB/              # EF Core 資料存取
│   └── AutoGenerated/             # EF 反向工程產生的實體
└── {ProjectName}.Contract/        # API 客戶端合約
    └── AutoGenerated/             # Refitter 產生的客戶端
```

**兩種組織方式**：
- **單一專案模式**：所有層（Controller/Handler/Repository）都在 WebAPI 專案內
- **多專案模式**：Controller、Handler、Repository 各自獨立專案

### 2. BDD 開發循環（Docker 優先）

```
需求分析 (.feature)
    ↓
測試實作 (Reqnroll)
    ↓
Docker 測試環境 (SQL Server + Redis + Seq)
    ↓
程式實作 (Controller → Handler → Repository)
    ↓
重構與優化
```

**核心原則**：
- ✅ **使用真實 Docker 容器**作為測試替身（Testcontainers）
- ✅ **API 測試必須使用 BDD**（.feature 檔案 + Reqnroll）
- ✅ **禁止單獨測試 Controller**：必須透過完整的 Web API 管線
- ❌ **避免 Mock**：只有外部服務才考慮 Mock

### 3. 分層職責劃分

#### Controller 層（HTTP 關注點）
```csharp
// ✅ 正確：只處理 HTTP 相關邏輯
[ApiController]
[Route("api/members")]
public class MemberController : ControllerBase
{
    private readonly MemberHandler _handler;
    
    [HttpGet("{id}")]
    public async Task<ActionResult<MemberResponse>> GetMember(string id)
    {
        var result = await _handler.GetMemberAsync(id);
        
        return result.IsSuccess 
            ? Ok(result.Value) 
            : NotFound(new { error = result.Error });
    }
}

// ❌ 錯誤：不應在 Controller 寫業務邏輯
public async Task<ActionResult> BadExample(string id)
{
    var member = await _repository.GetByIdAsync(id); // ❌ 直接呼叫 Repository
    if (member.IsVip) { /* 業務邏輯 */ }            // ❌ 業務邏輯應在 Handler
}
```

#### Handler 層（業務邏輯協調）
```csharp
public sealed class MemberHandler
{
    private readonly MemberRepository _repository;
    private readonly ICacheService _cache;
    private readonly ILogger<MemberHandler> _logger;
    
    public async Task<Result<MemberResponse>> GetMemberAsync(
        string id, 
        CancellationToken ct = default)
    {
        // 1. 驗證
        if (string.IsNullOrWhiteSpace(id))
            return Result.Failure<MemberResponse>("會員 ID 不可為空", "INVALID_ID");
        
        // 2. 快取檢查
        var cacheKey = $"member:{id}";
        var cached = await _cache.GetAsync<MemberResponse>(cacheKey, ct);
        if (cached != null) return Result.Success(cached);
        
        // 3. 資料庫查詢
        var member = await _repository.GetByIdAsync(id, ct);
        if (member == null)
            return Result.Failure<MemberResponse>("會員不存在", "NOT_FOUND");
        
        // 4. DTO 轉換與快取
        var response = MapToResponse(member);
        await _cache.SetAsync(cacheKey, response, TimeSpan.FromMinutes(15), ct);
        
        return Result.Success(response);
    }
}
```

#### Repository 層（資料存取）
```csharp
// 策略選擇：
// A) 資料表導向（小型專案）：MemberRepository 對應 Members 表
// B) 需求導向（推薦）：OrderManagementRepository 處理訂單相關所有表
// C) 混合模式（實務常見）：核心業務用 B，簡單主檔用 A

public sealed class MemberRepository
{
    private readonly JobBankContext _dbContext;
    
    // ✅ 使用 AsNoTracking 提升效能（只讀查詢）
    public async Task<Member?> GetByIdAsync(string id, CancellationToken ct)
    {
        return await _dbContext.Members
            .AsNoTracking()
            .FirstOrDefaultAsync(m => m.Id == id, ct);
    }
    
    // ✅ 避免 N+1 查詢，使用 Include
    public async Task<Member?> GetWithOrdersAsync(string id, CancellationToken ct)
    {
        return await _dbContext.Members
            .AsNoTracking()
            .Include(m => m.Orders)
            .FirstOrDefaultAsync(m => m.Id == id, ct);
    }
}
```

### 4. Result Pattern（錯誤處理）

使用 `CSharpFunctionalExtensions` 實作 Railway Oriented Programming：

```csharp
// ✅ 成功與失敗的明確表達
public async Task<Result<MemberResponse>> CreateMemberAsync(CreateMemberRequest request)
{
    // 驗證
    var validation = await _validator.ValidateAsync(request);
    if (!validation.IsValid)
        return Result.Failure<MemberResponse>(
            string.Join("; ", validation.Errors.Select(e => e.ErrorMessage)));
    
    // 重複檢查
    var exists = await _repository.ExistsByEmailAsync(request.Email);
    if (exists)
        return Result.Failure<MemberResponse>("Email 已被使用", "DUPLICATE_EMAIL");
    
    // 建立會員
    var member = new Member { /* ... */ };
    await _repository.CreateAsync(member);
    
    return Result.Success(MapToResponse(member));
}

// Controller 對應 HTTP 狀態碼
return result.IsSuccess 
    ? Ok(result.Value)
    : result.Error switch
    {
        "NOT_FOUND" => NotFound(new { error = result.Error }),
        "DUPLICATE_EMAIL" => Conflict(new { error = result.Error }),
        _ => BadRequest(new { error = result.Error })
    };
```

### 5. 多層快取策略（Redis + Memory）

```csharp
public class HybridCacheService : ICacheService
{
    private readonly IMemoryCache _l1Cache;         // L1: 記憶體快取
    private readonly IDistributedCache _l2Cache;    // L2: Redis
    
    public async Task<T?> GetAsync<T>(string key, CancellationToken ct)
    {
        // 優先從 L1 取得
        if (_l1Cache.TryGetValue(key, out T? value))
            return value;
        
        // L1 未命中，從 L2 取得
        var json = await _l2Cache.GetStringAsync(key, ct);
        if (json == null) return default;
        
        var data = JsonSerializer.Deserialize<T>(json);
        
        // 回寫 L1（較短過期時間）
        _l1Cache.Set(key, data, TimeSpan.FromMinutes(5));
        
        return data;
    }
}
```

### 6. TraceContext（不可變追蹤上下文）

```csharp
// ✅ 使用 record 實作不可變物件
public sealed record TraceContext
{
    public string TraceId { get; init; } = string.Empty;
    public string? UserId { get; init; }
    public string? UserName { get; init; }
    public string? IpAddress { get; init; }
    public DateTime RequestTime { get; init; }
}

// 中介軟體設定 TraceContext
public class TraceContextMiddleware
{
    public async Task InvokeAsync(HttpContext context, IContextSetter setter)
    {
        var traceContext = new TraceContext
        {
            TraceId = Activity.Current?.Id ?? Guid.NewGuid().ToString("N"),
            UserId = context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value,
            IpAddress = context.Connection.RemoteIpAddress?.ToString(),
            RequestTime = DateTime.UtcNow
        };
        
        setter.SetContext(traceContext);
        
        await _next(context);
    }
}

// Handler 透過 DI 取得
public class MemberHandler
{
    private readonly IContextGetter _contextGetter;
    
    public async Task LogOperation()
    {
        var trace = _contextGetter.GetContext();
        _logger.LogInformation(
            "User {UserId} performed action, TraceId: {TraceId}", 
            trace.UserId, trace.TraceId);
    }
}
```

### 7. API First 工作流程

```bash
# 1. 編輯 OpenAPI 規格
vim doc/openapi.yml

# 2. 產生伺服器控制器骨架（NSwag）
task codegen-api-server

# 3. 產生客戶端程式碼（Refitter）
task codegen-api-client

# 4. 實作業務邏輯（Handler + Repository）
# 自動產生的 Controller 在 Contract/AutoGenerated/
# 手動實作的 ControllerImpl 繼承自動產生的 Controller
```

**重要規範**：
- ❌ **禁止手動編輯** `AutoGenerated/` 資料夾內的檔案
- ✅ 所有變更應修改 `doc/openapi.yml` 後重新產生

### 8. EF Core 開發模式

#### Code First（推薦新專案）
```bash
# 建立新 Migration
task ef-migration-add NAME=AddMemberTable

# 更新資料庫
task ef-database-update
```

#### Database First（既有資料庫）
```bash
# 從資料庫反向工程產生實體
task ef-codegen

# 僅產生特定資料表
task ef-codegen TABLES=Members,Orders
```

**重要**：必須透過 Taskfile 執行，不可直接執行 `dotnet ef`。

## BDD 測試實踐

### 1. Gherkin 情境定義（.feature 檔案）

```gherkin
# src/be/{Project}.IntegrationTest/Member/MemberRegistration.feature

Feature: 會員註冊
  作為一個新使用者
  我想要註冊成為會員
  以便使用系統功能

  Scenario: 成功註冊新會員
    Given 我準備註冊會員資料
      | Email              | Name   | Password  |
      | test@example.com   | 測試員 | Pass@123  |
    When 我發送註冊請求
    Then 回應狀態碼應為 201
    And 回應中應包含會員 ID
    And 資料庫中應存在此會員

  Scenario: 重複 Email 註冊失敗
    Given 資料庫中已存在會員
      | Email              | Name   |
      | test@example.com   | 既有會員 |
    And 我準備註冊會員資料
      | Email              | Name   | Password  |
      | test@example.com   | 重複員 | Pass@456  |
    When 我發送註冊請求
    Then 回應狀態碼應為 409
    And 錯誤訊息應為 "Email 已被使用"
```

### 2. 測試步驟實作（Reqnroll）

```csharp
[Binding]
public class MemberRegistrationSteps
{
    private readonly TestServer _server;        // WebApplicationFactory
    private readonly HttpClient _client;
    private CreateMemberRequest _request = null!;
    private HttpResponseMessage _response = null!;
    
    public MemberRegistrationSteps(TestServer server)
    {
        _server = server;
        _client = server.CreateClient();
    }
    
    [Given(@"我準備註冊會員資料")]
    public void GivenPrepareRegistrationData(Table table)
    {
        var row = table.Rows[0];
        _request = new CreateMemberRequest
        {
            Email = row["Email"],
            Name = row["Name"],
            Password = row["Password"]
        };
    }
    
    [Given(@"資料庫中已存在會員")]
    public async Task GivenExistingMemberInDatabase(Table table)
    {
        var row = table.Rows[0];
        await _server.SeedMemberAsync(new Member
        {
            Email = row["Email"],
            Name = row["Name"],
            /* ... */
        });
    }
    
    [When(@"我發送註冊請求")]
    public async Task WhenSendRegistrationRequest()
    {
        _response = await _client.PostAsJsonAsync("/api/members", _request);
    }
    
    [Then(@"回應狀態碼應為 (.*)")]
    public void ThenResponseStatusCodeShouldBe(int expectedCode)
    {
        ((int)_response.StatusCode).Should().Be(expectedCode);
    }
    
    [Then(@"資料庫中應存在此會員")]
    public async Task ThenMemberShouldExistInDatabase()
    {
        var member = await _server.GetMemberByEmailAsync(_request.Email);
        member.Should().NotBeNull();
        member!.Email.Should().Be(_request.Email);
    }
}
```

### 3. Docker 測試環境設定

```csharp
public class TestServer : WebApplicationFactory<Program>
{
    private readonly MsSqlContainer _sqlContainer;
    private readonly RedisContainer _redisContainer;
    
    public TestServer()
    {
        // 啟動 SQL Server 容器
        _sqlContainer = new MsSqlBuilder()
            .WithImage("mcr.microsoft.com/mssql/server:2022-latest")
            .WithPassword("YourStrong@Passw0rd")
            .Build();
        
        // 啟動 Redis 容器
        _redisContainer = new RedisBuilder()
            .WithImage("redis:7-alpine")
            .Build();
    }
    
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureServices(services =>
        {
            // 替換為測試資料庫連線
            services.RemoveDbContext<JobBankContext>();
            services.AddDbContext<JobBankContext>(options =>
                options.UseSqlServer(_sqlContainer.GetConnectionString()));
            
            // 替換為測試 Redis
            services.Configure<CacheOptions>(options =>
            {
                options.RedisConnection = _redisContainer.GetConnectionString();
            });
        });
    }
}
```

## 常見模式與最佳實踐

### 1. 非同步模式

```csharp
// ✅ 正確：一致使用 async/await
public async Task<Result<Member>> GetMemberAsync(string id, CancellationToken ct)
{
    var member = await _repository.GetByIdAsync(id, ct);
    return member != null 
        ? Result.Success(member) 
        : Result.Failure<Member>("會員不存在");
}

// ❌ 錯誤：混用同步與非同步（可能造成死鎖）
public async Task<Member> BadExample(string id)
{
    var member = _repository.GetByIdAsync(id).Result;  // ❌ 不要使用 .Result
    return member;
}
```

### 2. 依賴注入生命週期

```csharp
// Program.cs 或 ServiceCollectionExtensions.cs
services.AddScoped<IMemberHandler, MemberHandler>();      // 每個 HTTP 請求一個實例
services.AddScoped<IMemberRepository, MemberRepository>();

services.AddSingleton<ICacheService, HybridCacheService>(); // 應用程式生命週期單例
services.AddSingleton<IConnectionMultiplexer>(/* Redis */);

services.AddTransient<IValidator<CreateMemberRequest>, CreateMemberValidator>(); // 每次注入都新建
```

### 3. 分頁查詢模式

```csharp
public record PagedRequest(int Page = 1, int PageSize = 20);

public async Task<Result<PagedResult<Member>>> SearchAsync(
    MemberSearchRequest request, 
    CancellationToken ct)
{
    var query = _dbContext.Members.AsNoTracking();
    
    // 套用篩選
    if (!string.IsNullOrWhiteSpace(request.Keyword))
        query = query.Where(m => m.Name.Contains(request.Keyword));
    
    // 計算總筆數
    var totalCount = await query.CountAsync(ct);
    
    // 分頁
    var pageSize = Math.Clamp(request.PageSize, 1, 100);
    var items = await query
        .Skip((request.Page - 1) * pageSize)
        .Take(pageSize)
        .ToListAsync(ct);
    
    return Result.Success(new PagedResult<Member>
    {
        Items = items,
        TotalCount = totalCount,
        Page = request.Page,
        PageSize = pageSize
    });
}
```

### 4. FluentValidation 驗證

```csharp
public class CreateMemberRequestValidator : AbstractValidator<CreateMemberRequest>
{
    public CreateMemberRequestValidator()
    {
        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("Email 為必填")
            .EmailAddress().WithMessage("Email 格式不正確");
        
        RuleFor(x => x.Password)
            .NotEmpty()
            .MinimumLength(8).WithMessage("密碼至少 8 個字元")
            .Matches(@"[A-Z]").WithMessage("密碼必須包含大寫字母")
            .Matches(@"\d").WithMessage("密碼必須包含數字");
        
        RuleFor(x => x.Name)
            .NotEmpty()
            .MaximumLength(50).WithMessage("姓名不可超過 50 個字元");
    }
}
```

## 開發指令（Taskfile）

```bash
# 開發模式執行 API
task api-dev

# 建置解決方案
task build

# 執行整合測試（BDD）
task test-integration

# 執行單元測試
task test-unit

# 從 OpenAPI 產生 API 程式碼
task codegen-api-server   # 產生伺服器控制器
task codegen-api-client    # 產生客戶端程式碼

# EF Core 指令
task ef-codegen                        # 從資料庫反向工程
task ef-migration-add NAME=InitialCreate   # 建立 Migration
task ef-database-update                # 更新資料庫
```

## 常見陷阱 (Common Pitfalls)

### 資料庫相關
- ❌ **N+1 查詢**：忘記使用 `.Include()` 載入關聯資料
- ❌ **過度查詢**：撈取整個實體但只用幾個欄位，應使用 `.Select()` 投影
- ❌ **缺少索引**：常用的篩選欄位未建立索引
- ❌ **未使用 AsNoTracking**：唯讀查詢忘記關閉變更追蹤

### 非同步模式
- ❌ **使用 .Result 或 .Wait()**：可能造成死鎖
- ❌ **缺少 CancellationToken**：無法取消長時間執行的操作
- ❌ **async void**：除了事件處理器外不應使用

### 快取策略
- ❌ **快取穿透**：未驗證輸入導致查詢不存在的資料
- ❌ **快取雪崩**：大量快取同時過期
- ❌ **未處理快取失效**：更新資料後未清除相關快取

### 測試實踐
- ❌ **直接測試 Controller**：應透過完整 Web API 管線測試
- ❌ **過度使用 Mock**：應優先使用 Testcontainers
- ❌ **測試資料未清理**：影響測試獨立性

## 資源檔案 (Resources)

- **assets/handler-template.cs**: Handler 實作範本（Result Pattern + 快取）
- **assets/repository-template.cs**: Repository 實作範本（EF Core）
- **assets/bdd-feature-template.feature**: BDD 情境範本（Gherkin）
- **assets/bdd-steps-template.cs**: BDD 測試步驟範本（Reqnroll）
- **references/trace-context-design.md**: TraceContext 設計說明
- **references/cache-strategy.md**: 多層快取策略詳解
- **references/openapi-codegen.md**: OpenAPI 程式碼產生工作流程

## 版本相容性

| 技術 | 版本 |
|------|------|
| .NET | 8.0+ |
| ASP.NET Core | 8.0+ |
| Entity Framework Core | 8.0+ |
| C# | 12+ |
| SQL Server | 2019+ / 2022+ |
| Redis | 6.0+ / 7.0+ |
| Docker | 20.10+ |
| Testcontainers | 3.10.0+ |
| Reqnroll | 2.1.1+ |
| xUnit | 2.9.2+ |
| FluentValidation | 11.10.0+ |
| CSharpFunctionalExtensions | 3.1.0+ |

## 相關技能

- `dotnet-backend-patterns`: 通用 .NET 後端開發模式
- `dotnet-project-generator`: .NET 專案產生器
- `bdd-testing-patterns`: BDD 測試模式與 Gherkin 語法

## 授權

MIT License
