# EF Core 最佳實踐

> Entity Framework Core 資料存取最佳實踐與常見陷阱

## 核心原則

### 1. 使用 IDbContextFactory 而非直接注入 DbContext

**問題**：直接注入 DbContext 會有生命週期問題
```csharp
// ❌ 錯誤：直接注入 DbContext
public class MemberRepository(AppDbContext dbContext)
{
    // 問題：DbContext 的生命週期難以控制
}
```

**解決方案**：使用 IDbContextFactory
```csharp
// ✅ 正確：使用 IDbContextFactory
public class MemberRepository(IDbContextFactory<AppDbContext> dbContextFactory)
{
    public async Task<Member> GetByIdAsync(Guid id, CancellationToken cancel = default)
    {
        // 每次操作建立新的 DbContext
        await using var dbContext = await dbContextFactory.CreateDbContextAsync(cancel);
        
        return await dbContext.Members
            .AsNoTracking()
            .FirstOrDefaultAsync(m => m.Id == id, cancel);
    }
}
```

**優勢**：
- ✅ 避免 DbContext 生命週期問題
- ✅ 支援並行操作
- ✅ 自動釋放資源（await using）
- ✅ 更好的效能（連線池）

### 2. 查詢最佳化

#### 使用 AsNoTracking() 提升唯讀查詢效能

```csharp
// ❌ 錯誤：追蹤不需要的實體
var members = await dbContext.Members
    .ToListAsync(cancel);  // 預設會追蹤所有實體

// ✅ 正確：唯讀查詢使用 AsNoTracking
var members = await dbContext.Members
    .AsNoTracking()  // 不追蹤實體，提升效能
    .ToListAsync(cancel);
```

**何時使用 AsNoTracking**：
- ✅ 查詢資料僅用於展示
- ✅ 不需要更新實體
- ✅ 大量資料查詢

**何時不使用**：
- ❌ 需要更新實體
- ❌ 需要追蹤變更

#### 避免 N+1 查詢問題

```csharp
// ❌ 錯誤：N+1 查詢問題
var orders = await dbContext.Orders.ToListAsync();
foreach (var order in orders)
{
    // 每個 order 都會觸發一次額外查詢
    var items = order.OrderItems.ToList();  // N+1 問題
}

// ✅ 正確：使用 Include 一次性載入
var orders = await dbContext.Orders
    .Include(o => o.OrderItems)  // 一次性載入關聯資料
    .ToListAsync(cancel);

// ✅ 更好：使用 ThenInclude 載入多層關聯
var orders = await dbContext.Orders
    .Include(o => o.OrderItems)
        .ThenInclude(i => i.Product)
    .Include(o => o.Payment)
    .ToListAsync(cancel);
```

#### 使用 Select 投影減少資料傳輸

```csharp
// ❌ 錯誤：載入整個實體
var members = await dbContext.Members
    .ToListAsync();  // 載入所有欄位

// ✅ 正確：只載入需要的欄位
var members = await dbContext.Members
    .Select(m => new MemberDto
    {
        Id = m.Id,
        Email = m.Email,
        Name = m.Name
        // 不載入不需要的欄位（如：密碼、大型欄位等）
    })
    .ToListAsync(cancel);
```

### 3. 交易管理

#### 明確的交易邊界

```csharp
public async Task<Result<Order>> CreateCompleteOrderAsync(
    CreateOrderRequest request, 
    CancellationToken cancel = default)
{
    await using var dbContext = await dbContextFactory.CreateDbContextAsync(cancel);
    
    // 明確開啟交易
    await using var transaction = await dbContext.Database.BeginTransactionAsync(cancel);
    
    try
    {
        // 1. 建立訂單
        var order = new Order { /* ... */ };
        dbContext.Orders.Add(order);
        
        // 2. 建立訂單明細
        var items = /* ... */;
        dbContext.OrderItems.AddRange(items);
        
        // 3. 更新庫存
        // ...
        
        // 儲存變更
        await dbContext.SaveChangesAsync(cancel);
        
        // 提交交易
        await transaction.CommitAsync(cancel);
        
        return Result.Success<Order, Failure>(order);
    }
    catch (Exception ex)
    {
        // 回滾交易
        await transaction.RollbackAsync(cancel);
        
        return Result.Failure<Order, Failure>(new Failure
        {
            Code = nameof(FailureCode.DbError),
            Message = "Order creation failed",
            Exception = ex
        });
    }
}
```

**重點**：
- ✅ 使用 `await using` 確保資源釋放
- ✅ 明確的 Commit/Rollback
- ✅ 異常處理包含交易回滾

### 4. 批次操作最佳化

```csharp
// ❌ 錯誤：逐筆插入
foreach (var member in members)
{
    dbContext.Members.Add(member);
    await dbContext.SaveChangesAsync();  // 每次都儲存，效能差
}

// ✅ 正確：批次插入
dbContext.Members.AddRange(members);
await dbContext.SaveChangesAsync(cancel);  // 一次儲存所有變更

// ✅ 更好：使用 BulkExtensions（第三方套件）
await dbContext.BulkInsertAsync(members, cancel);
```

### 5. Code First vs Database First

#### Code First Migration

**適用場景**：
- 新專案從頭開始
- 完全控制資料庫結構
- 版本控制需求高

**工作流程**：
```bash
# 1. 建立 Migration
task ef-migration-add NAME=AddMemberTable

# 2. 更新資料庫
task ef-database-update

# 3. 回復 Migration（如果需要）
task ef-migration-remove
```

**最佳實踐**：
```csharp
// 在 DbContext 中定義實體配置
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Member>(entity =>
    {
        entity.ToTable("Members");
        entity.HasKey(e => e.Id);
        entity.Property(e => e.Email).IsRequired().HasMaxLength(256);
        entity.HasIndex(e => e.Email).IsUnique();
    });
}
```

#### Database First (反向工程)

**適用場景**：
- 資料庫已存在
- DBA 管理資料庫結構
- 與現有系統整合

**工作流程**：
```bash
# 從資料庫反向工程產生實體
task ef-codegen
```

**重要規範**：
- ✅ 產生的程式碼放在 `AutoGenerated/` 資料夾
- ❌ 絕對不可手動編輯自動產生的程式碼
- ✅ 使用 Partial Class 擴展功能

```csharp
// AutoGenerated/Member.cs (自動產生，不可編輯)
public partial class Member
{
    public Guid Id { get; set; }
    public string Email { get; set; }
    public string Name { get; set; }
}

// Member.Extensions.cs (手動建立，可編輯)
public partial class Member
{
    // 擴展方法或屬性
    public string DisplayName => $"{Name} ({Email})";
}
```

### 6. 效能最佳化

#### 使用 DbContextPool

```csharp
// Program.cs
builder.Services.AddDbContextPool<AppDbContext>(options =>
    options.UseSqlServer(connectionString));
```

**優勢**：
- ✅ 重用 DbContext 實例
- ✅ 減少記憶體配置
- ✅ 提升效能

#### 編譯查詢

```csharp
// 定義編譯查詢
private static readonly Func<AppDbContext, Guid, Task<Member>> GetMemberByIdQuery =
    EF.CompileAsyncQuery((AppDbContext context, Guid id) =>
        context.Members
            .AsNoTracking()
            .FirstOrDefault(m => m.Id == id));

// 使用編譯查詢
public async Task<Member> GetByIdAsync(Guid id)
{
    await using var dbContext = await dbContextFactory.CreateDbContextAsync();
    return await GetMemberByIdQuery(dbContext, id);
}
```

#### 分頁查詢

```csharp
// ✅ 正確：使用 Skip + Take 分頁
public async Task<List<Member>> GetMembersAsync(
    int pageNumber, 
    int pageSize, 
    CancellationToken cancel = default)
{
    await using var dbContext = await dbContextFactory.CreateDbContextAsync(cancel);
    
    return await dbContext.Members
        .AsNoTracking()
        .OrderBy(m => m.CreatedAt)
        .Skip(pageNumber * pageSize)
        .Take(pageSize)
        .ToListAsync(cancel);
}
```

### 7. 併發控制

#### 使用 RowVersion 欄位

```csharp
public class Member
{
    public Guid Id { get; set; }
    public string Email { get; set; }
    
    [Timestamp]  // 併發權杖
    public byte[] RowVersion { get; set; }
}
```

#### 處理併發衝突

```csharp
public async Task<Result<Member>> UpdateAsync(
    Member member, 
    CancellationToken cancel = default)
{
    await using var dbContext = await dbContextFactory.CreateDbContextAsync(cancel);
    
    try
    {
        dbContext.Members.Update(member);
        await dbContext.SaveChangesAsync(cancel);
        
        return Result.Success<Member, Failure>(member);
    }
    catch (DbUpdateConcurrencyException ex)
    {
        return Result.Failure<Member, Failure>(new Failure
        {
            Code = nameof(FailureCode.DbConcurrency),
            Message = "The record has been modified by another user",
            Exception = ex
        });
    }
}
```

### 8. 常見陷阱與錯誤

#### ❌ 陷阱 1：在迴圈中執行查詢

```csharp
// ❌ 錯誤
foreach (var id in ids)
{
    var member = await dbContext.Members.FindAsync(id);  // N 次查詢
}

// ✅ 正確
var members = await dbContext.Members
    .Where(m => ids.Contains(m.Id))
    .ToListAsync();  // 1 次查詢
```

#### ❌ 陷阱 2：未傳遞 CancellationToken

```csharp
// ❌ 錯誤
public async Task<Member> GetByIdAsync(Guid id)
{
    return await dbContext.Members.FindAsync(id);  // 無法取消
}

// ✅ 正確
public async Task<Member> GetByIdAsync(Guid id, CancellationToken cancel = default)
{
    return await dbContext.Members
        .FirstOrDefaultAsync(m => m.Id == id, cancel);  // 可取消
}
```

#### ❌ 陷阱 3：使用 .Result 或 .Wait()

```csharp
// ❌ 錯誤：可能造成死鎖
var member = dbContext.Members.FindAsync(id).Result;

// ✅ 正確：使用 await
var member = await dbContext.Members.FindAsync(id, cancel);
```

#### ❌ 陷阱 4：未釋放 DbContext

```csharp
// ❌ 錯誤
var dbContext = await dbContextFactory.CreateDbContextAsync();
var member = await dbContext.Members.FindAsync(id);
// 忘記釋放

// ✅ 正確
await using var dbContext = await dbContextFactory.CreateDbContextAsync(cancel);
var member = await dbContext.Members.FindAsync(id, cancel);
// 自動釋放
```

## Taskfile 指令參考

### EF Core Migration 指令

```bash
# 建立新的 Migration
task ef-migration-add NAME=AddMemberTable

# 更新資料庫
task ef-database-update

# 移除最後一個 Migration
task ef-migration-remove

# 從資料庫反向工程
task ef-codegen
```

**重要**：
- ✅ 必須透過 Taskfile 執行
- ❌ 不應直接執行 `dotnet ef` 指令
- 原因：確保參數一致性與可重現性

## 檢查清單

### 開發時
- [ ] 使用 IDbContextFactory 而非直接注入 DbContext
- [ ] 唯讀查詢使用 AsNoTracking()
- [ ] 使用 Include 避免 N+1 問題
- [ ] 傳遞 CancellationToken
- [ ] 使用 await using 確保資源釋放

### 查詢最佳化
- [ ] 使用 Select 投影減少資料傳輸
- [ ] 使用分頁查詢（Skip + Take）
- [ ] 考慮使用編譯查詢（頻繁執行的查詢）

### 交易管理
- [ ] 明確的交易邊界
- [ ] 異常處理包含交易回滾
- [ ] 使用 await using 確保交易釋放

### Migration
- [ ] 透過 Taskfile 執行 EF Core 指令
- [ ] Migration 名稱清晰易懂
- [ ] 自動產生的程式碼放在 AutoGenerated/

---

**參考來源**：CLAUDE.md - EF Core 相關章節
