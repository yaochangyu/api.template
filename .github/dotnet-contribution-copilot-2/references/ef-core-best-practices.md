# EF Core 最佳實踐

## 核心原則

### 1. 必須透過 Taskfile 執行 EF Core 指令
❌ **禁止直接執行**:
```bash
dotnet ef migrations add AddMemberTable
dotnet ef database update
dotnet ef dbcontext scaffold
```

✅ **正確執行方式**:
```bash
task ef-migration-add NAME=AddMemberTable
task ef-database-update
task ef-codegen
```

**原因**:
- 統一管理專案路徑與參數
- 確保在正確的專案中執行
- 避免路徑錯誤與參數遺漏

## Code First vs Database First

### Code First (Migration 模式)
**適用場景**:
- 新專案開發
- 資料庫結構由開發團隊控制
- 需要版本控制資料庫變更

**工作流程**:
1. 定義或修改 Entity 類別
2. 建立 Migration: `task ef-migration-add NAME=<MigrationName>`
3. 檢視 Migration 檔案確認變更
4. 套用至資料庫: `task ef-database-update`

**範例**:
```csharp
// 1. 定義 Entity
public class Member
{
    public int Id { get; set; }
    public string Email { get; set; }
    public string Name { get; set; }
}

// 2. 建立 Migration
// task ef-migration-add NAME=CreateMemberTable

// 3. 套用至資料庫
// task ef-database-update
```

### Database First (反向工程模式)
**適用場景**:
- 現有資料庫專案
- 資料庫由 DBA 管理
- 多個系統共用同一資料庫

**工作流程**:
1. DBA 在資料庫中建立/修改資料表
2. 執行反向工程: `task ef-codegen`
3. 自動產生 Entity 與 DbContext 到 `AutoGenerated` 資料夾

**範例**:
```bash
# DBA 建立資料表後，執行反向工程
task ef-codegen

# 產生的檔案位置
# src/be/JobBank1111.Job.DB/AutoGenerated/Member.cs
# src/be/JobBank1111.Job.DB/AutoGenerated/JobBankDbContext.cs
```

## Migration 管理

### 建立 Migration
```bash
# 建立新的 Migration
task ef-migration-add NAME=AddMemberEmailIndex

# Migration 命名規範
# - 使用 PascalCase
# - 描述性名稱（說明做了什麼變更）
# - 範例: CreateMemberTable, AddEmailUniqueConstraint, RemoveObsoleteColumns
```

### 檢視 Migration
```bash
# 列出所有 Migration
task ef-migration-list

# 產生 SQL 腳本（不實際執行）
task ef-migration-script
```

### 套用 Migration
```bash
# 套用所有未執行的 Migration
task ef-database-update

# 套用至特定 Migration
task ef-database-update TARGET=AddMemberTable

# 回滾至特定 Migration
task ef-database-update TARGET=InitialCreate
```

### 移除 Migration
```bash
# 移除最後一個未套用的 Migration
task ef-migration-remove

# ⚠️ 注意：只能移除尚未套用至資料庫的 Migration
```

## 反向工程 (Scaffold-DbContext)

### 完整資料庫反向工程
```bash
# 產生所有資料表的 Entity
task ef-codegen
```

### 部分資料表反向工程
需要修改 `Taskfile.yml` 中的 `ef-codegen` task，加入 `--table` 參數:

```yaml
ef-codegen:
  desc: "從資料庫反向工程產生 Entity 類別"
  cmds:
    - |
      dotnet ef dbcontext scaffold 
      "Server=localhost;Database=JobBank;User Id=sa;Password=YourPassword;TrustServerCertificate=True;" 
      Microsoft.EntityFrameworkCore.SqlServer 
      --project src/be/JobBank1111.Job.DB 
      --output-dir AutoGenerated 
      --context-dir AutoGenerated 
      --context JobBankDbContext 
      --table Members 
      --table MemberLevels 
      --force
```

### 自動產生的檔案位置
```
src/be/JobBank1111.Job.DB/
└── AutoGenerated/          # ⚠️ 不可手動編輯
    ├── Member.cs
    ├── MemberLevel.cs
    ├── Order.cs
    └── JobBankDbContext.cs
```

## DbContext 設定

### Partial Class 擴展
自動產生的 `DbContext` 是 partial class，可透過另一個 partial class 檔案擴展:

```csharp
// AutoGenerated/JobBankDbContext.cs (自動產生，不可編輯)
public partial class JobBankDbContext : DbContext
{
    // 自動產生的內容
}

// JobBankDbContextExtensions.cs (手動建立)
public partial class JobBankDbContext
{
    // 自訂查詢方法
    public async Task<Member?> GetMemberByEmailAsync(string email)
    {
        return await Members
            .FirstOrDefaultAsync(m => m.Email == email);
    }
    
    // 覆寫 SaveChanges 加入審計邏輯
    public override async Task<int> SaveChangesAsync(
        CancellationToken cancellationToken = default)
    {
        AddAuditInfo();
        return await base.SaveChangesAsync(cancellationToken);
    }
}
```

## Entity 擴展

### 使用 Partial Class
```csharp
// AutoGenerated/Member.cs (自動產生)
public partial class Member
{
    public int Id { get; set; }
    public string Email { get; set; }
    public string Name { get; set; }
}

// Member.Extensions.cs (手動建立)
public partial class Member
{
    // 計算屬性
    public string DisplayName => $"{Name} ({Email})";
    
    // 業務邏輯方法
    public bool IsVip() => Level == "VIP";
}
```

### 使用 Fluent API 配置
```csharp
// AutoGenerated/JobBankDbContext.cs
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    OnModelCreatingPartial(modelBuilder);
}

partial void OnModelCreatingPartial(ModelBuilder modelBuilder);

// JobBankDbContextConfiguration.cs
public partial class JobBankDbContext
{
    partial void OnModelCreatingPartial(ModelBuilder modelBuilder)
    {
        // 自訂設定
        modelBuilder.Entity<Member>(entity =>
        {
            entity.HasIndex(e => e.Email).IsUnique();
            entity.Property(e => e.Email).HasMaxLength(200);
        });
    }
}
```

## 常見問題與解決方案

### Q1: Migration 與反向工程衝突
**問題**: 同時使用 Code First 和 Database First 導致衝突

**解決方案**: 
- 專案初期決定使用哪一種模式
- 建議中小型專案使用 Code First
- 大型企業專案由 DBA 管理使用 Database First

### Q2: AutoGenerated 檔案被覆蓋
**問題**: 重新執行 `task ef-codegen` 會覆蓋手動修改

**解決方案**:
- 使用 partial class 擴展功能
- 不要直接修改 `AutoGenerated` 資料夾中的檔案

### Q3: 連線字串管理
**問題**: 不同環境使用不同的連線字串

**解決方案**:
```csharp
// appsettings.Development.json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost;..."
  }
}

// appsettings.Production.json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=prod-server;..."
  }
}
```

## Taskfile 指令參考

```bash
# Migration 相關
task ef-migration-add NAME=<MigrationName>  # 建立 Migration
task ef-migration-list                      # 列出所有 Migration
task ef-migration-remove                    # 移除最後一個 Migration
task ef-migration-script                    # 產生 SQL 腳本

# 資料庫更新
task ef-database-update                     # 套用所有 Migration
task ef-database-update TARGET=<Migration>  # 套用至特定 Migration
task ef-database-drop                       # 刪除資料庫（危險）

# 反向工程
task ef-codegen                             # 從資料庫產生 Entity

# DbContext 相關
task ef-dbcontext-info                      # 顯示 DbContext 資訊
task ef-dbcontext-list                      # 列出所有 DbContext
```

## 最佳實踐檢查清單

- [ ] 所有 EF Core 指令都透過 Taskfile 執行
- [ ] Migration 檔案納入版本控制
- [ ] 不直接修改 `AutoGenerated` 資料夾的檔案
- [ ] 使用 partial class 擴展自動產生的類別
- [ ] 資料庫連線字串使用環境變數或 Secret Manager
- [ ] Migration 名稱具有描述性
- [ ] 執行 Migration 前先檢視 SQL 腳本
- [ ] 定期清理未使用的 Migration（開發階段）
